package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.63

import (
	"context"
	"fmt"
	dbmodels "nepseserver/database/models"
	"nepseserver/graph/model"
	"nepseserver/utils"
	"sort"

	"go.mongodb.org/mongo-driver/bson"
)

// GetMarketMovers is the resolver for the getMarketMovers field.
func (r *queryResolver) GetMarketMovers(ctx context.Context, top int32) (*model.MarketMovers, error) {
	collection := r.MongoClient.Collection("marketmovers")

	var marketMovers dbmodels.MarketMovers
	err := collection.FindOne(ctx, bson.M{}).Decode(&marketMovers)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch market movers: %v", err)
	}

	if int(top) > len(marketMovers.Gainers) || int(top) > len(marketMovers.Loser) {
		return nil, fmt.Errorf("requested top %d is greater than available gainers or losers", top)
	}

	return &model.MarketMovers{
		Gainers: mapMarketMovers(marketMovers.Gainers, top),
		Losers:  mapMarketMovers(marketMovers.Loser, top),
	}, nil
}

func mapMarketMovers(movers []dbmodels.MarketMover, top int32) []*model.MarketMover {
	var result []*model.MarketMover
	for _, mover := range movers {
		result = append(result, &model.MarketMover{
			StockSymbol:      mover.StockCode,
			CompanyName:      mover.Company,
			NoOfTransactions: int32(mover.TransactionsCount),
			MaxPrice:         mover.HighestPrice,
			MinPrice:         mover.LowestPrice,
			OpeningPrice:     mover.OpeningPrice,
			ClosingPrice:     mover.ClosingPrice,
			Amount:           mover.Turnover,
			PreviousClosing:  mover.PreviousClose,
			DifferenceRs:     mover.PriceChange,
			PercentChange:    mover.PercentageChange,
			Volume:           int32(mover.TradedVolume),
			TradeDate:        mover.TradeDate,
		})
	}

	if int(top) > len(result) {

	}

	sort.Slice(result, func(i, j int) bool {
		return result[i].PercentChange > result[j].PercentChange
	})

	if top <= 0 {
		top = 5
	}

	if int(top) < len(result) {
		result = result[:top]
	}
	return result
}

// GetNepseIndex is the resolver for the getNepseIndex field.
func (r *queryResolver) GetNepseIndex(ctx context.Context) (*model.NepseIndex, error) {
	collection := r.MongoClient.Collection("nepse-data")

	var nepseIndex dbmodels.NepseIndex
	err := collection.FindOne(ctx, bson.M{}).Decode(&nepseIndex)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch nepse index: %v", err)
	}

	return &model.NepseIndex{
		IndexName:     nepseIndex.MarketIndex,
		IndexValue:    nepseIndex.CurrentValue,
		PreviousValue: nepseIndex.PreviousClose,
		OpeningValue:  nepseIndex.OpeningValue,
		PercentChange: nepseIndex.PercentageChange,
		Difference:    nepseIndex.PointChange,
		Turnover:      nepseIndex.TotalTurnover,
		Volume:        int32(nepseIndex.TradedVolume),
		MarketCap:     nepseIndex.MarketCapitalization,
		DayHigh:       nepseIndex.DailyHigh,
		DayLow:        nepseIndex.DailyLow,
		YearHigh:      nepseIndex.YearlyHigh,
		YearLow:       nepseIndex.YearlyLow,
		AsOfDate:      nepseIndex.Date,
	}, nil
}

// GetMarkets is the resolver for the getMarkets field.
func (r *queryResolver) GetMarkets(ctx context.Context) ([]*model.Market, error) {
	collection := r.MongoClient.Collection("market-data")

	cursor, err := collection.Find(ctx, bson.M{})
	if err != nil {
		return nil, fmt.Errorf("failed to fetch markets: %v", err)
	}
	defer cursor.Close(ctx)

	var markets []*model.Market
	for cursor.Next(ctx) {
		var market dbmodels.Market
		if err := cursor.Decode(&market); err != nil {
			return nil, fmt.Errorf("failed to decode market: %v", err)
		}
		markets = append(markets, &model.Market{
			Symbol:           market.Symbol,
			Company:          market.Company,
			TradeVolume:      int32(market.TradeVolume),
			High:             market.High,
			Low:              market.Low,
			Open:             market.Open,
			Close:            market.Close,
			TotalTradedValue: market.TotalTradedValue,
			PrevClose:        market.PrevClose,
			PriceChange:      market.PriceChange,
			PercentChange:    market.PercentChange,
			ShareVolume:      int32(market.ShareVolume),
			Lastupdated:      market.LastUpdated,
		})
	}

	if err := cursor.Err(); err != nil {
		return nil, fmt.Errorf("cursor error: %v", err)
	}

	return markets, nil
}

// GetIndices is the resolver for the getIndices field.
func (r *queryResolver) GetIndices(ctx context.Context, top int32) ([]*model.Indices, error) {
	collection := r.MongoClient.Collection("indices-data")

	cursor, err := collection.Find(ctx, bson.M{})
	if err != nil {
		return nil, fmt.Errorf("failed to fetch indices: %v", err)
	}
	defer cursor.Close(ctx)

	var indices []*model.Indices
	for cursor.Next(ctx) {
		var index dbmodels.Indices
		if err := cursor.Decode(&index); err != nil {
			return nil, fmt.Errorf("failed to decode index: %v", err)
		}
		indices = append(indices, &model.Indices{
			IndexName:           index.IndexName,
			IndexValue:          index.IndexValue,
			PreviousValue:       index.PreviousValue,
			OpeningValue:        index.OpeningValue,
			PercentChange:       index.PercentChange,
			Difference:          index.Difference,
			Turnover:            index.Turnover,
			Volume:              int32(index.Volume),
			NoOfListedCompanies: int32(index.TotalCompanies),
			NoOfTradedCompanies: int32(index.TradedCompanies),
			NoOfTransactions:    int32(index.Transactions),
			NoOfListedShares:    int32(index.ListedShares),
			MarketCap:           index.MarketCap,
			DayHigh:             index.DailyHigh,
			DayLow:              index.DailyLow,
			YearHigh:            index.YearlyHigh,
			YearLow:             index.YearlyLow,
			AsOfDate:            index.ReportDate,
			AsOfDateString:      index.ReportDateString,
			NoOfGainers:         int32(index.GainingCompanies),
			NoOfLosers:          int32(index.LosingCompanies),
			NoOfUnchanged:       int32(index.Unchanged),
		})
	}
	if int(top) > len(indices) {
		return nil, fmt.Errorf("only %d indices available", len(indices))
	}
	if err := cursor.Err(); err != nil {
		return nil, fmt.Errorf("cursor error: %v", err)
	}

	sort.Slice(indices, func(i, j int) bool {
		return indices[i].PercentChange > indices[j].PercentChange
	})

	if top <= 0 {
		top = 5
	}

	if int(top) < len(indices) {
		indices = indices[:top]
	}

	return indices, nil
}

// GetIPOAndFpoAlerts is the resolver for the getIPOAndFpoAlerts field.
func (r *queryResolver) GetIPOAndFpoAlerts(ctx context.Context) (*model.IPOAndFpoAlert, error) {
	collection := r.MongoClient.Collection("ipo-fpo")

	var ipoAndFpoAlert dbmodels.IPOAndFpoAlert
	err := collection.FindOne(ctx, bson.M{}).Decode(&ipoAndFpoAlert)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch IPO and FPO alerts: %v", err)
	}

	return &model.IPOAndFpoAlert{
		Ipo: mapIPOAlerts(ipoAndFpoAlert.Ipo),
		Fpo: mapIPOAlerts(ipoAndFpoAlert.Fpo),
	}, nil
}

func mapIPOAlerts(alerts []dbmodels.IPOAlert) []*model.IPOAlert {
	var result []*model.IPOAlert
	for _, alert := range alerts {
		result = append(result, &model.IPOAlert{
			CompanyName:            alert.IssuerName,
			StockSymbol:            alert.StockSymbol,
			ShareRegistrar:         alert.ShareRegistrar,
			SectorName:             alert.IndustrySector,
			ShareType:              alert.ShareType,
			PricePerUnit:           alert.UnitPrice,
			Rating:                 alert.Rating,
			Units:                  alert.NumberOfShares,
			MinUnits:               alert.MinimumUnits,
			MaxUnits:               alert.MaximumUnits,
			TotalAmount:            alert.TotalApplicationAmount,
			OpeningDateAd:          alert.ApplicationStartDateAD,
			OpeningDateBs:          alert.ApplicationStartDateBS,
			ClosingDateAd:          alert.ApplicationEndDateAD,
			ClosingDateBs:          alert.ApplicationEndDateBS,
			ClosingDateClosingTime: alert.ApplicationClosingTime,
			Status:                 alert.Status,
		})
	}
	return result
}

// GetMarketBySymbol is the resolver for the getMarketBySymbol field.
func (r *queryResolver) GetMarketBySymbol(ctx context.Context, stockSymbol string) (*model.Market, error) {
	collection := r.MongoClient.Collection("market-data")

	var market dbmodels.Market
	err := collection.FindOne(ctx, bson.M{"symbol": stockSymbol}).Decode(&market)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch market by symbol: %v", err)
	}

	return &model.Market{
		Symbol:           market.Symbol,
		Company:          market.Company,
		TradeVolume:      int32(market.TradeVolume),
		High:             market.High,
		Low:              market.Low,
		Open:             market.Open,
		Close:            market.Close,
		TotalTradedValue: market.TotalTradedValue,
		PrevClose:        market.PrevClose,
		PriceChange:      market.PriceChange,
		PercentChange:    market.PercentChange,
		ShareVolume:      int32(market.ShareVolume),
		Lastupdated:      market.LastUpdated,
	}, nil
}

// GetMarketStatus is the resolver for the getMarketStatus field.
func (r *queryResolver) GetMarketStatus(ctx context.Context) (*model.MarketStatus, error) {
	return &model.MarketStatus{
		IsMarketOpen: utils.IsMarketOpenGlobal,
	}, nil
}

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }
